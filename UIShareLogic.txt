1. Architectural Pattern: Partial InjectionTo optimize performance and maintainability, the system strictly separates the Static Layout (Frame) from the Dynamic Content (Data)1.Main View (Index): Acting as the "Shell," it contains the Header, Search Bar, Action Buttons, and a target DIV container (e.g., #data-list-container)2.The Shell must NOT contain data-rendering logic3.List Partial (_List): Responsible only for rendering the data table and pagination links4. It is purely server-side rendered and returned as HTML via AJAX5.Detail/Edit Partial (_Detail): A modular form loaded into a shared Modal container on demand6.2. Initialization & State ManagementOn Page Load: The Main View must execute a loadList() function via JavaScript7.Search/Filter: Any change in search criteria must reset the Page Index to 1 and trigger loadList(criteria, 1)8.Stateless Navigation: The URL remains clean, while the AJAX request carries the state (Keyword, PageNumber, SortOrder)9.3. Communication Flow (The AJAX Loop)All data-fetching operations must follow this abstract cycle10:Trigger: User interacts (Search, Page Click, Refresh)11.Request: JS gathers all active filters and sends a GET request to the Controller12.Processing: The Controller queries the database using Skip() and Take() for backend pagination13.Delivery: The Controller returns a PartialView containing only the relevant HTML fragment14.Injection: JS replaces the content of the target container with the received HTML15.4. Generic Table RulesFor every data-list rendered in a Partial View:Row Index (STT): Calculate the sequence number based on the current page to ensure continuity:$$STT = (CurrentPage - 1) \times PageSize + CurrentRowIndex + 1$$16Data Formatting: All timestamps must be formatted to a human-readable string (e.g., dd/MM/yyyy HH:mm:ss) at the Backend/DTO level before delivery17.Status Indicators: Categorize statuses into logical states (Pending, Success, Error) and map them to consistent UI elements (Badges/Icons)18.5. Generic Action Logic (CRUD)A. View/Edit Action (Modal-Based)Fetch the _Detail Partial View using the Entity ID19.Inject the HTML into a Shared Modal Container20.On Update, send a POST request21. On success, hide the Modal and trigger a List Refresh22.B. Destructive Actions (Delete)Intercept: All delete clicks must be intercepted by a Confirmation Dialog (e.g., SweetAlert2)23.Verify: The user must explicitly confirm the action24.Execute: If confirmed, send the DELETE request25.Sync: Upon success, remove data from both the Primary DB and Secondary Systems (e.g., Qdrant Vector DB)26.Refresh: Always reload the List Partial to reflect the change27.6. Modal Content & Scrollability LogicTo maintain a high-quality User Experience in multi-tenant management:Scrollable Boundaries: Any Modal containing a Partial View must enforce a max-height (e.g., 80vh) on the content body.Overflow Management: Apply overflow-y: auto to the modal container to allow scrolling long forms without losing sight of the Modal Header or Footer.Auto-Focus & Auto-Scroll: After injecting HTML into the Modal, execute an auto-focus delay:setTimeout(() => inputField.focus(), 100);This ensures the browser renders the DOM and automatically scrolls the view to the primary input field.7. Feedback & UX GuardrailsLoading States: Always show a visual indicator (Spinner/Overlay) while a Partial View is being fetched28.Action Feedback: Every AJAX Post/Put/Delete must return a JSON response indicating success or failure29.Global Error Handling: All AJAX calls must have a .fail() or .catch() block to alert the user if the server is unreachable or an exception occurs30.